import typing as t

from atproto.firehose.client import AsyncFirehoseClient, FirehoseClient
from atproto.xrpc_client import models
from atproto.xrpc_client.models.utils import get_or_create_model

if t.TYPE_CHECKING:
    from atproto.firehose.models import MessageFrame

# TODO(MarshalX): Everything here could be autogenerated from the lexicon.

_SUBSCRIBE_REPOS_MESSAGE_TYPE_TO_MODEL = {
    '#commit': models.ComAtprotoSyncSubscribeRepos.Commit,
    '#handle': models.ComAtprotoSyncSubscribeRepos.Handle,
    '#migrate': models.ComAtprotoSyncSubscribeRepos.Migrate,
    '#tombstone': models.ComAtprotoSyncSubscribeRepos.Tombstone,
    '#info': models.ComAtprotoSyncSubscribeRepos.Info,
}
_SUBSCRIBE_LABELS_MESSAGE_TYPE_TO_MODEL = {
    '#label': models.ComAtprotoLabelSubscribeLabels.Labels,
    '#info': models.ComAtprotoLabelSubscribeLabels.Info,
}

SubscribeReposMessage = t.Union[
    models.ComAtprotoSyncSubscribeRepos.Commit,
    models.ComAtprotoSyncSubscribeRepos.Handle,
    models.ComAtprotoSyncSubscribeRepos.Migrate,
    models.ComAtprotoSyncSubscribeRepos.Tombstone,
    models.ComAtprotoSyncSubscribeRepos.Info,
]
SubscribeLabelsMessage = t.Union[
    models.ComAtprotoLabelSubscribeLabels.Labels,
    models.ComAtprotoLabelSubscribeLabels.Info,
]


def parse_subscribe_repos_message(message: 'MessageFrame') -> SubscribeReposMessage:
    model_class = _SUBSCRIBE_REPOS_MESSAGE_TYPE_TO_MODEL[message.type]
    return get_or_create_model(message.body, model_class)


def parse_subscribe_labels_message(message: 'MessageFrame') -> SubscribeLabelsMessage:
    model_class = _SUBSCRIBE_LABELS_MESSAGE_TYPE_TO_MODEL[message.type]
    return get_or_create_model(message.body, model_class)


class FirehoseSubscribeReposClient(FirehoseClient):
    def __init__(self, params: t.Optional[t.Union[dict, 'models.ComAtprotoSyncSubscribeRepos.Params']] = None):
        params = get_or_create_model(params, models.ComAtprotoSyncSubscribeRepos.Params)
        super().__init__(method='com.atproto.sync.subscribeRepos', params=params)


class AsyncFirehoseSubscribeReposClient(AsyncFirehoseClient):
    def __init__(self, params: t.Optional[t.Union[dict, 'models.ComAtprotoSyncSubscribeRepos.Params']] = None):
        params = get_or_create_model(params, models.ComAtprotoSyncSubscribeRepos.Params)
        super().__init__(method='com.atproto.sync.subscribeRepos', params=params)


# TODO(MarshalX): SubscribeLabels doesn't work yet?


class FirehoseSubscribeLabelsClient(FirehoseClient):
    def __init__(self, params: t.Optional[t.Union[dict, 'models.ComAtprotoLabelSubscribeLabels']] = None):
        params = get_or_create_model(params, models.ComAtprotoLabelSubscribeLabels.Params)
        super().__init__(method='com.atproto.label.subscribeLabels', params=params)


class AsyncFirehoseSubscribeLabelsClient(AsyncFirehoseClient):
    def __init__(self, params: t.Optional[t.Union[dict, 'models.ComAtprotoLabelSubscribeLabels']] = None):
        params = get_or_create_model(params, models.ComAtprotoLabelSubscribeLabels.Params)
        super().__init__(method='com.atproto.label.subscribeLabels', params=params)


def _parse_message_body(msg: 'MessageFrame'):
    from atproto import CAR

    model = parse_subscribe_repos_message(msg)

    if isinstance(model, models.ComAtprotoSyncSubscribeRepos.Commit):
        model.blocks = CAR.from_bytes(model.blocks)

    return model


def _main_test():
    client = FirehoseSubscribeReposClient()
    # client = FirehoseSubscribeLabelsClient()

    def on_message_handler(message: 'MessageFrame') -> None:
        print('Message', message.header, _parse_message_body(message))

    client.start(on_message_handler)


async def _main_async_test():
    client = AsyncFirehoseSubscribeReposClient()
    # client = AsyncFirehoseSubscribeLabelsClient()

    async def on_message_handler(message: 'MessageFrame') -> None:
        print('Message', message.header, _parse_message_body(message))
        await asyncio.sleep(0.1)

    await client.start(on_message_handler)


if __name__ == '__main__':
    import asyncio

    _main_test()
    # asyncio.get_event_loop().run_until_complete(_main_async_test())
